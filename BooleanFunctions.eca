require import AllCore FinType.

require import FunSamplingLib.


type in_t.
type out_t.

clone import FinType as FinIn with
  type t <- in_t.

clone import FinType as FinOut with
  type t <- out_t.

axiom gt1_cardout: 1 < FinOut.card.

clone import LambdaReprogram as LR with
  type X <= in_t,
  type Y <= out_t,
  
  theory MUFF.FinT <= FinIn,
  theory MFY.Support <= FinOut
  
  proof *.
  realize Ynontriv by exact: gt1_cardout.


module type BFOFi_t = {
   proc init() : unit
   proc query(x : in_t) : bool
}.

module type BFOF_t = {
   include BFOFi_t [-init]
}.

module type Adv_BFFind(O : BFOF_t) = {
  proc find() : in_t
}.

module BF_Find(A : Adv_BFFind, O : BFOFi_t) = {
  proc main() = {
    var x : in_t;
    var b : bool;
    
    O.init();
    
    x <@ A(O).find();
    
    b <@ O.query(x);
    
    return b;
  } 
}.


module type BFODi_t = {
   proc init(b : bool) : unit
   proc query(x : in_t) : bool
}.

module type BFOD_t = {
   include BFODi_t [-init]
}.

module type Adv_BFDistinguish(O : BFOD_t) = {
  proc distinguish() : bool
}.

module BF_Distinguish(A : Adv_BFDistinguish, O : BFODi_t) = {
  proc main(b : bool) = {
    var b' : bool;
    
    O.init(b);
    
    b' <@ A(O).distinguish();
    
    return b';
  }
}.


module BFOF : BFOFi_t = {
  var f : in_t -> bool
  
  proc init() = {
    f <$ dboolf;
  }
  
  proc query(x : in_t) : bool = {
    return f x;
  }
}.

module BFOD : BFODi_t = {
  var f : in_t -> bool
  
  proc init(b : bool) = {
    if (b) {
      f <$ dboolf;
    } else {
      f <- fun (x : in_t) => false;
    }
  }
  
  proc query(x : in_t) : bool = {
    return f x;
  }
}.


module (R_BFDistinguish_BFFind (A : Adv_BFFind) : Adv_BFDistinguish) (O : BFOD_t) = {
  proc distinguish() : bool = {
    var x : in_t;
    var b : bool;
    
    x <@ A(O).find();
    
    b <@ O.query(x);
    
    return b;
  }
}.


equiv Equiv_Find_DistinguishT (A <: Adv_BFFind {-BFOF, -BFOD}) :
  BF_Find(A, BFOF).main ~ BF_Distinguish(R_BFDistinguish_BFFind(A), BFOD).main : 
    ={glob A} /\ b{2} ==> ={res}.
proof.
proc; inline *.
rcondt{2} 2; 1: by auto.
wp; call (: ={f}(BFOF, BFOD)); 1: by proc.
by rnd; wp; skip.
qed.

lemma Find_Implies_Distinguish &m (A <: Adv_BFFind {-BFOF, -BFOD}) :
  Pr[BF_Find(A, BFOF).main() @ &m : res]
  =
  `| Pr[BF_Distinguish(R_BFDistinguish_BFFind(A), BFOD).main(false) @ &m : res] - 
     Pr[BF_Distinguish(R_BFDistinguish_BFFind(A), BFOD).main(true) @ &m : res] |.
proof.
have -> /=: Pr[BF_Distinguish(R_BFDistinguish_BFFind(A), BFOD).main(false) @ &m : res] = 0%r.
+ byphoare (: !b ==> _) => //.
  hoare.
  proc; inline *.
  rcondf 2; 1: by wp.
  wp; call (: true) => //.
  by wp.
rewrite StdOrder.RealOrder.normrN StdOrder.RealOrder.ger0_norm 1:Pr[mu_ge0] //.
by byequiv (Equiv_Find_DistinguishT A).
qed.
