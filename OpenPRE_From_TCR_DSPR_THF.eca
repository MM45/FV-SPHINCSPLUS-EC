require import AllCore List Distr.
require import FinType Finite. 
require StdBigop StdOrder DMap.
import StdBigop.Bigreal BRA.
import StdOrder.RealOrder.
import RField.

require TweakableHashFunctions.

(*
type df_t.
*)

type pp_t.
type tw_t.
type in_t.

clone import FinType as InFT with
  type t <= in_t.

type out_t.

op f : pp_t -> tw_t -> in_t -> out_t.

(*
op gd : in_t -> df_t.

op fc : df_t -> pp_t -> tw_t -> in_t -> out_t.
axiom in_collection: exists (df : df_t), fc df = f.
*)

op [lossless] dpp : pp_t distr.
op [lossless full uniform] din : in_t distr.

const t : { int | 0 <= t } as ge0_t.

clone import TweakableHashFunctions as F with
  type pp_t <- pp_t,
  type tw_t <- tw_t,
  type in_t <- in_t,
  type out_t <- out_t,
  
  op f <- f,
  
  op dpp <- dpp
  
  proof *.
  realize dpp_ll by exact: dpp_ll.

clone import F.SMDTOpenPRE as F_OpenPRE with
  op t_smdtopenpre <- t,
  
  op din <- din
  
  proof *.
  realize ge0_tsmdtopenpre by exact: ge0_t.
  realize din_ll by exact: din_ll.

clone import F.SMDTTCR as F_TCR with
  op t_smdttcr <- t
  
  proof *.
  realize ge0_tsmdttcr by exact: ge0_t.

clone import F.SMDTDSPR as F_DSPR with
  op t_smdtdspr <- t
  
  proof *.
  realize ge0_tsmdtdspr by exact: ge0_t.  

module (R_TCR_OpenPRE (A : Adv_SMDTOpenPRE) : Adv_SMDTTCR) (O : Oracle_SMDTTCR) = {
  var ys : out_t list
  
  module O_SMDTOpenPRE : Oracle_SMDTOpenPRE = {
    include var O_SMDTOpenPRE_Default [-init]
    
    proc init(pp_init : pp_t, tws_init : tw_t list) : out_t list = {
      var x : in_t;
      var y : out_t;
      var ys : out_t list;
      var tw : tw_t;
      var twy : tw_t * out_t;
      
      (* pp <- pp_init; (Don't need pp, we use given oracle) *)
      ts <- [];
      xs <- [];
      os <- [];
      
      ys <- [];
      while (size ts < min (size tws_init) t) {
        tw <- nth witness tws_init (size ts);
        x <$ din;
        
        y <@ O.query(tw, x);
        
        twy <- (tw, y);
        
        xs <- rcons xs x;
        ys <- rcons ys y;
        ts <- rcons ts twy;
      }
      
      return ys;
    }
  }
      
  proc pick() : unit = {
    var tws : tw_t list;
    
    tws <@ A(O_SMDTOpenPRE).pick();
    
    ys <@ O_SMDTOpenPRE.init(witness, tws);
  }
  
  proc find(pp : pp_t) : int * in_t = {
    var i : int;
    var x' : in_t;
    
    (i, x') <@ A(O_SMDTOpenPRE).find(pp, ys);
    
    return (i, x');
  }
}.

module (R_DSPR_OpenPRE (A : Adv_SMDTOpenPRE) : Adv_SMDTDSPR) (O : Oracle_SMDTDSPR) = {
  var ys : out_t list
  
  module O_SMDTOpenPRE : Oracle_SMDTOpenPRE = {
    include var O_SMDTOpenPRE_Default [-init]
    
    proc init(pp_init : pp_t, tws_init : tw_t list) : out_t list = {
      var x : in_t;
      var y : out_t;
      var ys : out_t list;
      var tw : tw_t;
      var twy : tw_t * out_t;
      
      (* pp <- pp_init; (Don't need pp, we use given oracle) *)
      ts <- [];
      xs <- [];
      os <- [];
      
      ys <- [];
      while (size ts < min (size tws_init) t) {
        tw <- nth witness tws_init (size ts);
        x <$ din;
        
        y <@ O.query(tw, x);
        
        twy <- (tw, y);
        
        xs <- rcons xs x;
        ys <- rcons ys y;
        ts <- rcons ts twy;
      }
      
      return ys;
    }
  }

  proc pick() : unit = {
    var tws : tw_t list;
    
    tws <@ A(O_SMDTOpenPRE).pick();
    
    ys <@ O_SMDTOpenPRE.init(witness, tws);
  }
  
  proc guess(pp : pp_t) : int * bool = {
    var i : int;
    var x, x' : in_t;
    var nrts : int;
    var opened, dist, b : bool;
    var twsO : tw_t list;
    
    (i, x') <@ A(O_SMDTOpenPRE).find(pp, ys);
    
    nrts <@ O_SMDTOpenPRE.nr_targets();
    opened <@ O_SMDTOpenPRE.opened(i);
    dist <@ O_SMDTOpenPRE.dist_tweaks();
        
    x <- nth witness O_SMDTOpenPRE_Default.xs i; (* <@ O_SMDTOpenPRE.open(i); *)
    
    b <- x <> x' \/ ! (0 <= i < nrts /\ 0 <= nrts <= t /\ !opened /\ dist);
    
    return (i, b);
  }
}.


section Proof_OpenPRE_From_DSPR_TCR.

import RField DMap MRat RealSeries.
import StdBigop.Bigreal BRA.
import StdOrder.RealOrder
.
local lemma mem_size_ge1 (s : 'a list) (x : 'a) :
  x \in s => 1 <= size s.
proof. elim: s => //; smt(size_ge0). qed.

local lemma mem_size_ge2 (s : 'a list) (x x' : 'a) :
  x \in s => x' \in s => x <> x' => 2 <= size s.
proof. elim: s => //; smt(size_ge0). qed.

local lemma uniq_size_ge2_mem (s : 'a list) :
  uniq s => 2 <= size s => 
    exists (x x' : 'a), x <> x' /\ x \in s /\ x' \in s.
proof. elim: s => // /#. qed.


local op is_pre_f (pp : pp_t) (tw : tw_t) (y : out_t) : in_t -> bool = 
  fun (x : in_t) => f pp tw x = y.
 
local op pre_f_l (pp : pp_t) (tw : tw_t) (y : out_t) : in_t list =
  to_seq (is_pre_f pp tw y).
  
local lemma is_finite_ispref (pp : pp_t) (tw : tw_t) (y : out_t) : 
  is_finite (is_pre_f pp tw y).
proof. by rewrite (finite_leq predT) 2:-/finite_type 2:is_finite. qed.

local lemma ltcard_szprefl (pp : pp_t) (tw : tw_t) (y : out_t) :
  size (pre_f_l pp tw y) <= card.
proof. by rewrite card_size_to_seq sub_size_to_seq 2:-/finite_type 2:is_finite. qed. 

local lemma rngprefl_image (pp : pp_t) (tw : tw_t) (x : in_t) :
  1 <= size (pre_f_l pp tw (f pp tw x)) <= card.
proof.
split => [| _]; 2: by apply ltcard_szprefl.
apply (mem_size_ge1 _ x).
by rewrite mem_to_seq 1:is_finite_ispref.
qed.

local lemma eqv_spex_szprefl (pp : pp_t) (tw : tw_t) (x : in_t) :
  spexists f pp tw x 
  <=> 
  2 <= size (pre_f_l pp tw (f pp tw x)).
proof.
split=> [| @/pre_f_l ge2_szprefl]. 
+ elim => x' [neqx_xp eqfkx_fkxp].
  by apply (mem_size_ge2 _ x x'); 1,2: rewrite mem_to_seq 1:is_finite_ispref // /#.
move: (uniq_to_seq (is_pre_f pp tw (f pp tw x))).
move/uniq_size_ge2_mem => /(_ ge2_szprefl) -[x' x''] [#] neqxp_xpp xpin xppin.
case (x' = x) => [eqx_xp | neqx_xp].
+ exists x''; split; 1: by rewrite -eqx_xp. 
  by move: xppin; rewrite mem_to_seq 1:is_finite_ispref /#.
exists x'; rewrite eq_sym neqx_xp /=. 
by move: xpin; rewrite mem_to_seq 1:is_finite_ispref /#.
qed.

local lemma eqv_img_prefl (pp : pp_t) (tw : tw_t) (x x' : in_t) :
  f pp tw x = f pp tw x' 
  <=> 
  pre_f_l pp tw (f pp tw x) = pre_f_l pp tw (f pp tw x').
proof.
split => [-> // | @/pre_f_l eq_prefl].
move: (to_seq_finite (is_pre_f pp tw (f pp tw x)) _); 1: by apply is_finite_ispref.  
rewrite uniq_to_seq /= => /(_ x') /iffLR /(_ _).
+ by rewrite eq_prefl to_seq_finite 1:is_finite_ispref.
by rewrite /is_pre_f => ->.
qed.

local lemma eqv_img_mem (pp : pp_t) (tw : tw_t) (x x' : in_t) :
  f pp tw x = f pp tw x' 
  <=> 
  x' \in pre_f_l pp tw (f pp tw x).
proof. by rewrite to_seq_finite 1:is_finite_ispref /is_pre_f; split => ->. qed.
  
local lemma eqv_prefl_mem (pp : pp_t) (tw : tw_t) (x x' : in_t) :
  x' \in pre_f_l pp tw (f pp tw x) 
  <=> 
  pre_f_l pp tw (f pp tw x) = pre_f_l pp tw (f pp tw x').
proof. by rewrite -eqv_img_mem eqv_img_prefl. qed.

declare module A <: Adv_SMDTOpenPRE {-O_SMDTOpenPRE_Default, -O_SMDTDSPR_Default}.

declare axiom A_pick_ll (O <: Oracle_SMDTOpenPRE {-A}) : 
  islossless A(O).pick.

declare axiom A_find_ll (O <: Oracle_SMDTOpenPRE {-A}) :
  islossless O.open => islossless A(O).find.


local module Si = {
  var x, x' : in_t
  
  proc main(_i : int, _j : int) : bool = {
    var pp : pp_t;
    var tw : tw_t;
    var tws : tw_t list;
    var y : out_t;
    var ys : out_t list;
    var nrts : int;
    var opened, dist : bool;
    var twsO : tw_t list;
    var i : int;
    
    pp <$ dpp;
    
    tws <@ A(O_SMDTOpenPRE_Default).pick();
    
    ys <@ O_SMDTOpenPRE_Default.init(pp, tws);
    
    (i, x') <@ A(O_SMDTOpenPRE_Default).find(pp, ys);
    
    (tw, y) <@ O_SMDTOpenPRE_Default.get(i);
    
    nrts <@ O_SMDTOpenPRE_Default.nr_targets();
    opened <@ O_SMDTOpenPRE_Default.opened(i);
    dist <@ O_SMDTOpenPRE_Default.dist_tweaks();
    
    x <- nth witness O_SMDTOpenPRE_Default.xs i;
    
    return i = _j /\ size (pre_f_l pp tw y) = _i 
           /\ (0 <= i < nrts /\ 0 <= nrts <= t /\ !opened /\ dist /\ f pp tw x' = y);
  }
}.

local module Fi = {
  proc main(_i : int, _j : int) : bool = {
    var pp : pp_t;
    var tw : tw_t;
    var tws : tw_t list;
    var y : out_t;
    var ys : out_t list;
    var nrts : int;
    var opened, dist : bool;    
    var x, x' : in_t;
    var twsO : tw_t list;
    var i : int;
    
    pp <$ dpp;
    
    tws <@ A(O_SMDTOpenPRE_Default).pick();
    
    ys <@ O_SMDTOpenPRE_Default.init(pp, tws);
    
    (i, x') <@ A(O_SMDTOpenPRE_Default).find(pp, ys);
    
    (tw, y) <@ O_SMDTOpenPRE_Default.get(i);
    nrts <@ O_SMDTOpenPRE_Default.nr_targets();
    opened <@ O_SMDTOpenPRE_Default.opened(i);
    dist <@ O_SMDTOpenPRE_Default.dist_tweaks();
    
    x <- nth witness O_SMDTOpenPRE_Default.xs i;
    
    return i = _j /\ size (pre_f_l pp tw y) = _i 
           /\ ! (0 <= i < nrts /\ 0 <= nrts <= t /\ !opened /\ dist /\ f pp tw x' = y);
  }
}.

local module O_SMDTOpenPRE_Default_early_fail = {
  var _i : int
  var _j : int
  var r : bool

  include var O_SMDTOpenPRE_Default [-init]

  proc sample(pp : pp_t, tw : tw_t, ii : int) : in_t * out_t * bool = {
    var xt : in_t;
    var y : out_t;
    var rr : bool;
    
    xt <$ din;

    if (size (pre_f_l pp tw (f pp tw xt)) = ii) {
      y <- f pp tw xt;
      rr <- true;
    } else {
      rr <- false;
      xt <- witness;
      y <- witness;
    }
    
    return (xt, y, rr);
  }
  
  proc init(pp_init : pp_t, tws_init : tw_t list) : out_t list = {
    var x : in_t;
    var y : out_t;
    var ys : out_t list;
    var tw : tw_t;
    var twy : tw_t * out_t;
    
    pp <- pp_init;
    ts <- [];
    xs <- [];
    os <- [];
    ys <- [];
    while (size ts < min (size tws_init) t){
      tw <- nth witness tws_init (size ts);
      if (size ts = _j) {
        (x,y,r) <@ sample(pp,tw,_i);
      }
      else {
        x <$ din;
        y <- f pp tw x;     
      }
      twy <- (tw, y);
      xs <- rcons xs x;
      ys <- rcons ys y;
      ts <- rcons ts twy;
    }
    
    return ys;
  }
}.

local module Si_early_fail = {
  var x, x' : in_t
  
  proc main(_i : int, _j : int) : bool = {
    var pp : pp_t;
    var tw : tw_t;
    var tws : tw_t list;
    var y : out_t;
    var ys : out_t list;
    var nrts : int;
    var opened, dist : bool;
    var twsO : tw_t list;
    var i : int;
    
    O_SMDTOpenPRE_Default_early_fail.r <- true;
    O_SMDTOpenPRE_Default_early_fail._i <- _i;
    O_SMDTOpenPRE_Default_early_fail._j <- _j;

    pp <$ dpp;
    
    tws <@ A(O_SMDTOpenPRE_Default_early_fail).pick();
    
    ys <@ O_SMDTOpenPRE_Default_early_fail.init(pp, tws);
    
    (i, x') <@ A(O_SMDTOpenPRE_Default_early_fail).find(pp, ys);
    
    (tw, y) <@ O_SMDTOpenPRE_Default_early_fail.get(i);
    
    nrts <@ O_SMDTOpenPRE_Default_early_fail.nr_targets();
    opened <@ O_SMDTOpenPRE_Default_early_fail.opened(i);
    dist <@ O_SMDTOpenPRE_Default_early_fail.dist_tweaks();
    
    x <- nth witness O_SMDTOpenPRE_Default.xs i;
    
    return i = _j /\ O_SMDTOpenPRE_Default_early_fail.r 
         /\ (0 <= i < nrts /\ 0 <= nrts <= t /\ !opened /\ dist /\ f pp tw x' = y);
  }
}.

local proc op Si_early_fail_sample_sem = O_SMDTOpenPRE_Default_early_fail.sample.


local module O_SMDTOpenPRE_Default_inverse_sample = {

  include var O_SMDTOpenPRE_Default 
        [-init,open,get,get_tweaks,nr_targets,dist_tweaks,opened]
  include var O_SMDTOpenPRE_Default_early_fail [-init,sample]

  proc sample(pp : pp_t, tw : tw_t, ii : int) : in_t * out_t * bool = {
    var xt : in_t;
    var y : out_t;
    var rr : bool;
    
    y <$ dmap din (f pp tw);

    if (size (pre_f_l pp tw y) = ii) {
      xt <$ drat (pre_f_l pp tw y);
      rr <- true;
    } else {
      xt <- witness;
      y <- witness;
      rr <- false;     
    }

    
    return (xt, y, rr);
  }
  
  proc init(pp_init : pp_t, tws_init : tw_t list) : out_t list = {
    var x : in_t;
    var y : out_t;
    var ys : out_t list;
    var tw : tw_t;
    var twy : tw_t * out_t;
    
    pp <- pp_init;
    ts <- [];
    xs <- [];
    os <- [];
    ys <- [];
    while (size ts < min (size tws_init) t){
      tw <- nth witness tws_init (size ts);
      if (size ts = _j) {
        (x,y,r) <@ sample(pp,tw,_i);
      }
      else {
        x <$ din;
        y <- f pp tw x;     
      }
      twy <- (tw, y);
      xs <- rcons xs x;
      ys <- rcons ys y;
      ts <- rcons ts twy;
    }
    
    return ys;
  }
}.

local module Si_inverse_sample = {
  var x, x' : in_t
  
  proc main(_i : int, _j : int) : bool = {
    var pp : pp_t;
    var tw : tw_t;
    var tws : tw_t list;
    var y : out_t;
    var ys : out_t list;
    var nrts : int;
    var opened, dist : bool;
    var twsO : tw_t list;
    var i : int;
    
    O_SMDTOpenPRE_Default_early_fail.r <- true;
    O_SMDTOpenPRE_Default_early_fail._i <- _i;
    O_SMDTOpenPRE_Default_early_fail._j <- _j;

    pp <$ dpp;
    
    tws <@ A(O_SMDTOpenPRE_Default_inverse_sample).pick();
    
    ys <@ O_SMDTOpenPRE_Default_inverse_sample.init(pp, tws);
    
    (i, x') <@ A(O_SMDTOpenPRE_Default_inverse_sample).find(pp, ys);
    
    (tw, y) <@ O_SMDTOpenPRE_Default_inverse_sample.get(i);
    
    nrts <@ O_SMDTOpenPRE_Default_inverse_sample.nr_targets();
    opened <@ O_SMDTOpenPRE_Default_inverse_sample.opened(i);
    dist <@ O_SMDTOpenPRE_Default_inverse_sample.dist_tweaks();
    
    x <- nth witness O_SMDTOpenPRE_Default.xs i;
    
    return i = _j /\ O_SMDTOpenPRE_Default_early_fail.r 
          /\ (0 <= i < nrts /\ 0 <= nrts <= t /\ !opened /\ dist /\ f pp tw x' = y);
  }
}.

local proc op Si_inverse_sample_sample_sem = O_SMDTOpenPRE_Default_inverse_sample.sample.


lemma fin_sum_type (s : 'a -> real) :
     is_finite predT<:'a>
  => sum s = big predT s (to_seq predT<:'a>).
proof. by apply (fin_sum_cond predT s). qed.

lemma sumr_const_val (P : 'a -> bool) (F : 'a -> real) (x : real) (s : 'a list):
     (forall (i : 'a), P i => F i = x) 
  => big P F s = (count P s)%r * x.
proof. by rewrite -sumr_const &(eq_bigr). qed.

lemma sumr_const_val_seq (P : 'a -> bool) (F : 'a -> real) (x : real) (s : 'a list):
     (forall (i : 'a), i \in s /\ P i => F i = x) 
  => big P F s = (count P s)%r * x.
proof. 
move=> ?; rewrite -sumr_const big_mkcond eq_sym big_mkcond. 
apply eq_big_seq => i' ipin /= /#. 
qed.

  
local lemma Si_eq_sem pp tw i:
    Si_early_fail_sample_sem pp tw i
  = Si_inverse_sample_sample_sem pp tw i.
proof. 
rewrite /Si_early_fail_sample_sem /Si_inverse_sample_sample_sem /=.
rewrite dlet_dmap /= /dmap /(\o) eq_distr => -[b x y] /=; rewrite 2?dlet1E.
case (i <= 0) => [le0_i | /ltzNge gt0_i].
+ apply eq_sum => x' /=. 
  rewrite (: size (pre_f_l pp tw (f pp tw x')) <> i) /=; 1: smt(rngprefl_image).
  by congr; rewrite dmap1E /(\o) /pred1 /= /#.
do 2! (rewrite (sumE_fin _ enum) 1:enum_uniq => [? _ |]; 1: by rewrite enumP).
case ((b, x, y) = (false, witness, witness)) => [-> /= | neql].
+ apply eq_bigr => z _ /=; congr.
  case (size (pre_f_l pp tw (f pp tw z)) = i) => ? /=.
  - rewrite dlet_dlet /= dlet1E dunit1E /= sum0_eq // => x' /=.
    rewrite mulf_eq0; right.
    by rewrite dmap1E /pred1 /(\o) dunitE.
  by rewrite dmap1E /= /pred1 /(\o) /= 2?dunitE //.
case (y = f pp tw x /\ b) => [[-> ->] | /negb_and neqfkx_y]; last first.
+ rewrite ?big1 // => z _ /=.
  - by case (size (pre_f_l pp tw (f pp tw z)) = i) => ? /=; rewrite dunit1E /#.
  case (size (pre_f_l pp tw (f pp tw z)) = i) => ? /=.
  - rewrite dlet_dlet /= dlet1E sum0_eq //=. 
    move=> z'; rewrite dmap1E /pred1 /(\o) /=.
    rewrite mulf_eq0; case (z' \in (pre_f_l pp tw (f pp tw z))) => zpin; [right | left].
    * rewrite dunitE /=; case (z' = x) => [->> | //] /=.
      by rewrite (: f pp tw z = f pp tw x) 1:eqv_img_mem // /#. 
    rewrite prratE count_uniq_mem 1:uniq_to_seq /#.
  by rewrite dmap1E /pred1 /(\o) dunitE /#.
pose flundenum := flatten (undup (map (fun z => pre_f_l pp tw (f pp tw z)) enum)).
have permenum: perm_eq enum flundenum.
+ rewrite perm_eqP_pred1 => x'; rewrite enum_spec eq_sym.
  rewrite count_flatten StdBigop.Bigint.sumzE StdBigop.Bigint.BIA.big_mapT /(\o).
  rewrite (StdBigop.Bigint.BIA.bigD1 _ _ (pre_f_l pp tw (f pp tw x'))) 2:undup_uniq.
  - by rewrite mem_undup mapP; exists x'; rewrite enumP.
  rewrite StdBigop.Bigint.BIA.big1_seq /=; 1: move => xl -[@/predC1 neqxl].
  - rewrite mem_undup mapP => -[z /= [zin ->>]].
    by rewrite count_uniq_mem 1:uniq_to_seq  /=; smt(eqv_prefl_mem).
  by rewrite count_uniq_mem 2:to_seq_finite 1:uniq_to_seq 1:is_finite_ispref /#.
rewrite (eq_big_perm _ _ _ flundenum) // eq_sym (eq_big_perm _ _ _ flundenum) //.
rewrite ?big_flatten ?big_seq &(eq_bigr) => s /=.
rewrite mem_undup mapP => -[z /= [zin ->]]; rewrite 2?big_seq.
case (size (pre_f_l pp tw (f pp tw z)) = i) => [eqi_szfkz | neqi_szfkz]; last first.
+ rewrite &(eq_bigr) => z' /= zpin; congr.
  rewrite (: size (pre_f_l pp tw (f pp tw z')) <> i) /=; 1: smt(eqv_prefl_mem).
  by rewrite dmap1E dunit1E /pred1 /(\o) dunitE.
case (x \in pre_f_l pp tw (f pp tw z)) => [xin | xnin]; last first.
+ rewrite big1 2:eq_sym 1:/predT /= => [z' ^ /eqv_prefl_mem <- zpin |].
  - rewrite eqi_szfkz /= dlet_dlet dlet1E sum0_eq // => z'' /=.
    rewrite mulf_eq0; right; rewrite dlet1E sum0_eq // => r /=.
    case (r = (true, z'', f pp tw z')) => [-> | neqr] /=; last first.
    * by rewrite mulf_eq0; left; rewrite dunit1E [_ = r]eq_sym neqr. 
    by rewrite mulf_eq0; right; rewrite dunit1E; smt(eqv_img_mem).
  rewrite big1 // => z' zpin /=; rewrite mulf_eq0 /=.
  right; move/eqv_prefl_mem: (zpin) => <-.
  by rewrite eqi_szfkz /= dunit1E; smt(eqv_img_mem).
rewrite &(eq_trans _ (inv card%r)) 2:eq_sym; last first.
+ rewrite (bigD1_cond _ _ _ x) 1,2:// 1:uniq_to_seq /=.
  rewrite -(addr0 (inv card%r)); congr; 1: rewrite -(mulr1 (inv card%r)).
  - congr; 1: rewrite mu1_uni_ll 1:din_uni 1:din_ll din_fu /=.
    * rewrite card_size_to_seq; do 4! congr.
      by rewrite fun_ext => ? @/predT; rewrite eqT din_fu. 
    by move/eqv_prefl_mem: (xin) => <-; rewrite dunit1E eqi_szfkz.
  rewrite big1 /predI /predC1 // => z' [^ zpin /eqv_prefl_mem eqprefl neqxzp] /=.
  by rewrite mulf_eq0; right; rewrite dunit1E -eqprefl eqi_szfkz /= neqxzp.
rewrite (sumr_const_val _ _ ((inv card%r) * (inv i%r))) /= => [z' ^ zpin /eqv_prefl_mem <-| ].
+ rewrite eqi_szfkz /= invfM; congr.
  - rewrite mu1_uni_ll 1:din_uni 1:din_ll din_fu /=.
    rewrite card_size_to_seq; do 4! congr.
    by rewrite fun_ext => ? @/predT; rewrite eqT din_fu.
  rewrite dlet_dlet dlet1E /= (sumE_fin _ (pre_f_l pp tw (f pp tw z))).
  - by rewrite uniq_to_seq is_finite_ispref. 
  - move=> z'' /=; apply contraLR => /= znin.
    by rewrite prratE /= count_uniq_mem 1:uniq_to_seq znin /b2i.
  rewrite (bigD1 _ _ x) 1:// 1:uniq_to_seq  /=.
  rewrite -(addr0 (inv i%r)); congr; last first.
  - apply big1_seq => z'' @/predC1 [neqxzpp zppin] /=.
    by rewrite mulf_eq0; right; rewrite dmap1E /pred1 /(\o) dunitE /= neqxzpp.
  rewrite -(mulr1 (inv i%r)); congr.
  - by rewrite prratE count_uniq_mem 1:uniq_to_seq  xin eqi_szfkz /b2i.
  rewrite dmap1E dunitE /pred1 /(\o) /=.
  by move/eqv_img_mem: xin zpin => <- /eqv_img_mem <-.  
by rewrite count_predT_eq_in 1:// eqi_szfkz /= mulrC invfM -mulrA mulVf 1:/#.
qed.


local clone import DMapSampling as DMS with
  type t1 <- in_t,
  type t2 <- out_t
  
  proof *.

local module O_SMDTOpenPRE_Default_inverse_sample_alt = {

  include var O_SMDTOpenPRE_Default 
        [-init,open,get,get_tweaks,nr_targets,dist_tweaks,opened]
  include var O_SMDTOpenPRE_Default_early_fail [-init,sample]

  var yj : out_t
  
  proc init(pp_init : pp_t, tws_init : tw_t list) : out_t list = {
    var x : in_t;
    var y : out_t;
    var ys : out_t list;
    var tw : tw_t;
    var twy : tw_t * out_t;
    
    pp <- pp_init;
    ts <- [];
    xs <- [];
    os <- [];
    ys <- [];

    while (size ts < min (size tws_init) t && 
           size ts < _j){
      tw <- nth witness tws_init (size ts);
      x <$ din;
      y <- f pp tw x;     
      twy <- (tw, y);
      xs <- rcons xs x;
      ys <- rcons ys y;
      ts <- rcons ts twy;
    }

    if (size ts < min (size tws_init) t && 
        size ts = _j){
      tw <- nth witness tws_init (size ts);
      yj <$ dmap din (f pp_init tw);
      if (size (pre_f_l pp tw yj) = _i) {
        y <- yj;
        x <- witness;
        r <- true;
      } else {
        x <- witness;
        y <- witness;
        r <- false;     
      }
      twy <- (tw, y);
      xs <- rcons xs x;
      ys <- rcons ys y;
      ts <- rcons ts twy;
    }

    while (size ts < min (size tws_init) t){
      tw <- nth witness tws_init (size ts);
      x <$ din;
      y <- f pp tw x;     
      twy <- (tw, y);
      xs <- rcons xs x;
      ys <- rcons ys y;
      ts <- rcons ts twy;
    }
    
    return ys;
  }
}.

local module Si_inverse_sample_alt = {
  var x, x' : in_t
  
  proc same_as_si(_i : int, _j : int) = {
    var pp : pp_t;
    var tw : tw_t;
    var tws : tw_t list;
    var y : out_t;
    var ys : out_t list;
    var nrts : int;
    var opened, dist : bool;
    var twsO : tw_t list;
    var i : int;

    O_SMDTOpenPRE_Default_early_fail.r <- true;
    O_SMDTOpenPRE_Default_early_fail._i <- _i;
    O_SMDTOpenPRE_Default_early_fail._j <- _j;

    pp <$ dpp;
    
    tws <@ A(O_SMDTOpenPRE_Default_inverse_sample_alt).pick();
    
    ys <@ O_SMDTOpenPRE_Default_inverse_sample_alt.init(pp, tws);
    
    (i, x') <@ A(O_SMDTOpenPRE_Default_inverse_sample_alt).find(pp, ys);
    
    (tw, y) <@ O_SMDTOpenPRE_Default_inverse_sample_alt.get(i);
    
    nrts <@ O_SMDTOpenPRE_Default_inverse_sample_alt.nr_targets();
    opened <@ O_SMDTOpenPRE_Default_inverse_sample_alt.opened(i);
    dist <@ O_SMDTOpenPRE_Default_inverse_sample_alt.dist_tweaks();

    return (pp,tws,i,nrts,opened,dist,tw,y);
  }

  proc main(_i : int, _j : int) : bool = {
    var ll,_pp,_tws,ii,_nrts,_opened,_dist,_tw,_y;
    
    (_pp,_tws,ii,_nrts,_opened,_dist,_tw,_y) <@ same_as_si(_i,_j);
    
    ll <- if (size (pre_f_l _pp (nth witness _tws _j) O_SMDTOpenPRE_Default_inverse_sample_alt.yj) = 0) 
        then [witness] else  (pre_f_l _pp (nth witness _tws _j) O_SMDTOpenPRE_Default_inverse_sample_alt.yj);
    x <$ drat ll;
    return ii = _j /\ O_SMDTOpenPRE_Default_early_fail.r 
       /\ (0 <= ii < _nrts /\ 0 <= _nrts <= t /\ !_opened /\ _dist /\ f _pp _tw x' = _y);
  }
}.

local lemma pr_Si_Sief (ii jj : int) &m:
  Pr[Si.main(ii,jj) @ &m : res /\ Si.x' <> Si.x]
  =
  Pr[Si_early_fail.main(ii,jj) @ &m : res /\ Si_early_fail.x' <> Si_early_fail.x].
proof.
byequiv (: _i{1} = ii /\ _j{1} = jj /\ ={glob A,_i,_j} ==> 
     ={res} /\ (res{2} => ={x, x'}(Si, Si_early_fail))) => [| // | /#].
proc => /=; inline *.
swap {2} [4..11] -3.
seq 8 8 : (#pre /\ ={pp,tws,tws_init,glob O_SMDTOpenPRE_Default} 
     /\ O_SMDTOpenPRE_Default.ts{2} = [] /\ pp{1} = O_SMDTOpenPRE_Default.pp{2}); 
   1: by  swap {1} 6 -5; swap {2} 6 -5; sp 1 1; conseq />;sim.
sp 0 3.
seq 3 3 : ( ={tws_init,pp,glob A,_i,_j,pp, O_SMDTOpenPRE_Default.pp} 
   /\ size O_SMDTOpenPRE_Default.ts{1} = size O_SMDTOpenPRE_Default.ts{2} 
   /\ pp{1} = O_SMDTOpenPRE_Default.pp{2} 
   /\ O_SMDTOpenPRE_Default_early_fail._i{2} = _i{2} 
   /\ O_SMDTOpenPRE_Default_early_fail._j{2} = _j{2} 
   /\ _i{1} = ii /\ _j{1} = jj 
   /\ (O_SMDTOpenPRE_Default_early_fail.r{2} => 
         ={ys,O_SMDTOpenPRE_Default.os, O_SMDTOpenPRE_Default.xs, O_SMDTOpenPRE_Default.ts} 
       /\ (0 <= _j{1} < min (size O_SMDTOpenPRE_Default.ts{1}) t => (
           size (pre_f_l pp{1} 
             (nth witness O_SMDTOpenPRE_Default.ts{1} _j{1}).`1 
               (nth witness O_SMDTOpenPRE_Default.ts{1} _j{1}).`2) = _i{1})))
   /\ (!O_SMDTOpenPRE_Default_early_fail.r{2} => 
    (0 <= _j{1} < min (size O_SMDTOpenPRE_Default.ts{1}) t /\
           size (pre_f_l pp{1} 
             (nth witness O_SMDTOpenPRE_Default.ts{1} _j{1}).`1 
               (nth witness O_SMDTOpenPRE_Default.ts{1} _j{1}).`2) <> _i{1}))
); last first. 
+ case (O_SMDTOpenPRE_Default_early_fail.r{2}).
  + wp;call (: ={glob O_SMDTOpenPRE_Default}); 1: by sim.
    by skip => /> /#.
  wp  => /=. 
  call{1} (A_find_ll O_SMDTOpenPRE_Default); 1: by islossless. 
  call{2} (A_find_ll O_SMDTOpenPRE_Default_early_fail); 1: by islossless.
  by auto => /> /#. 

wp;while (#post); last by auto => /> /#.
by sp;if{2};auto => />;smt(nth_rcons size_rcons size_ge0).
qed.

local lemma pr_Sief_Siis (ii jj : int) &m:
  Pr[Si_early_fail.main(ii,jj) @ &m : res /\ Si_early_fail.x' <> Si_early_fail.x]
  =
  Pr[Si_inverse_sample.main(ii,jj) @ &m : res /\ Si_inverse_sample.x' <> Si_inverse_sample.x].
proof.
case (0 <= jj) => bdj;last first.
+ have ->:
    Pr[Si_early_fail.main(ii,jj) @ &m : res /\ Si_early_fail.x' <> Si_early_fail.x] = 0%r.
  - byphoare (_: arg.`2 < 0 ==> _) => //=;2:smt().
    hoare.
    proc.
    do 6!(wp;call (: true);1:by auto).
    by call(:true);auto; smt().
  byphoare (_: arg.`2 < 0 ==> _) => //=;2:smt().
  hoare.
  proc.
  do 6!(wp;call (: true);1:by auto).
  by call(:true);auto; smt().
  
case (0 < ii) => bdi;last first.
+ have ->:
    Pr[Si_early_fail.main(ii,jj) @ &m : res /\ Si_early_fail.x' <> Si_early_fail.x] = 0%r.
  - byphoare (_: arg.`1 <= 0 /\ _j = jj /\ _i = ii ==> _) => //=;2:smt().
    hoare.
    proc => /=;inline *;wp.  call(:true);1:by auto.
    wp;while(
         O_SMDTOpenPRE_Default_early_fail._j = jj /\ _j = jj 
      /\ O_SMDTOpenPRE_Default_early_fail._i = ii /\ _i = ii
      /\ 0 <= size O_SMDTOpenPRE_Default.ts <= min (size tws_init) t 
      /\ (jj < min (size tws_init) t => jj < size O_SMDTOpenPRE_Default.ts => 
             !O_SMDTOpenPRE_Default_early_fail.r)); last 
      by wp;call(:true);auto => />;smt(ge0_t size_ge0).
    sp;if; by auto => />;smt(size_rcons size_ge0 rngprefl_image).
  byphoare (_: arg.`1 <= 0 /\ _j = jj /\ _i = ii ==> _) => //=;2:smt().
  hoare.
  proc => /=;inline *;wp.  call(:true);1:by auto.
  wp;while(
       O_SMDTOpenPRE_Default_early_fail._j = jj /\ _j = jj 
    /\ O_SMDTOpenPRE_Default_early_fail._i = ii /\ _i = ii
    /\ 0 <= size O_SMDTOpenPRE_Default.ts <= min (size tws_init) t 
    /\ (jj < min (size tws_init) t => jj < size O_SMDTOpenPRE_Default.ts => 
           !O_SMDTOpenPRE_Default_early_fail.r)); last 
    by wp;call(:true);auto => />;smt(ge0_t size_ge0).
  sp;if;2: by auto => />;smt(size_rcons size_ge0 rngprefl_image). search pre_f_l .
  by rcondf 5; auto => />;smt(size_rcons size_ge0 rngprefl_image supp_dmap).

byequiv (: arg{2}.`1 = ii /\ arg{2}.`2=jj /\ ={arg,glob A} ==> 
     ={res} /\ Si_early_fail.x{1} = Si_inverse_sample.x{2} 
     /\ Si_early_fail.x'{1} = Si_inverse_sample.x'{2}) => //=.
proc => /=.
inline {1} 6; inline {2} 6.
swap {1} [4..11] -3.
swap {2} [4..11] -3.
seq 8 8 : (#pre /\ ={pp,tws,tws_init,glob O_SMDTOpenPRE_Default, glob A} 
     /\ O_SMDTOpenPRE_Default.ts{2} = [] 
     /\ pp{1} = O_SMDTOpenPRE_Default.pp{2}); 1: by wp;call(:true);auto => />.
sp 3 3.
seq 3 3 :(#{/~O_SMDTOpenPRE_Default.ts{2} = []}
           {~O_SMDTOpenPRE_Default_early_fail.r{1} = true}
           {~O_SMDTOpenPRE_Default_early_fail.r{2} = true}pre 
            /\ ={ys0,ys,O_SMDTOpenPRE_Default_early_fail.r}); last first.  
+ inline *;wp;call(: ={glob O_SMDTOpenPRE_Default}); 1: by sim.
  by auto => />.  

wp; while(#{/~O_SMDTOpenPRE_Default.ts{2} = []}
           {~O_SMDTOpenPRE_Default_early_fail.r{1} = true}
           {~O_SMDTOpenPRE_Default_early_fail.r{2} = true}pre 
           /\ ={ys0,O_SMDTOpenPRE_Default_early_fail.r}); last by auto => />.
sp;if;1,3: by auto => />.
wp. 
call (: ={pp,tw,ii} /\ 0 < arg{1}.`3 ==> ={res}); last by auto => />. 
bypr (res{1}) (res{2}) => //=.
move=> &1 &2 /> -[] x y r eq_pp eq_tw eq_ii gt0_ii.
rewrite Si_early_fail_sample_sem_opsem Si_inverse_sample_sample_sem_opsem. 
by rewrite eq_tw eq_ii eq_pp; congr; smt(Si_eq_sem).
qed.

local lemma pr_Siis_Siisa (ii jj : int) &m:  
  Pr[Si_inverse_sample.main(ii,jj) @ &m : res /\ Si_inverse_sample.x' <> Si_inverse_sample.x]
  =
  Pr[Si_inverse_sample_alt.main(ii,jj) @ &m : res /\ Si_inverse_sample_alt.x' <> Si_inverse_sample_alt.x].
proof.
byequiv (: arg{2}.`1 = ii /\ arg{2}.`2=jj /\ ={arg,glob A}
             ==> res{1} /\ Si_inverse_sample.x'{1} <> Si_inverse_sample.x{1} 
                 <=>
                 res{2} /\ Si_inverse_sample_alt.x'{2} <> Si_inverse_sample_alt.x{2}) => //.
proc; inline *.
swap {1} [4..5] -3; swap {2} [6..7] -5.
seq 2 2 : (#pre /\ ={pp,tws});1: by sim />.

splitwhile {1} 11 : (size O_SMDTOpenPRE_Default.ts < jj).
unroll {1} 12.

seq 11 13 : (={_j,_i,ys0,pp_init,glob O_SMDTOpenPRE_Default_early_fail,tws,tws_init, glob A,pp} 
       /\ tws_init{1} = tws{1} 
       /\ _i{1} = ii /\ _j{1} = jj 
       /\ size O_SMDTOpenPRE_Default.ts{2} = size O_SMDTOpenPRE_Default.xs{2} 
       /\ size ys0{2} = size O_SMDTOpenPRE_Default.ts{2} 
       /\ (0 <= jj => size O_SMDTOpenPRE_Default.ts{1} <= jj)
       /\ O_SMDTOpenPRE_Default_early_fail._j{1} = jj
       /\ O_SMDTOpenPRE_Default_early_fail._i{1} = ii
       /\ O_SMDTOpenPRE_Default.pp{1} = pp_init{1} 
       /\ pp{1} = pp_init{1}
       /\ size O_SMDTOpenPRE_Default.ts{1} <= min (size tws_init{1}) t
       /\ (!(size O_SMDTOpenPRE_Default.ts{1} < min (size tws_init{1}) t /\
            size O_SMDTOpenPRE_Default.ts{1} < jj))). 
+ while (#[/:-2]post).
  + rcondf {1} 2; 1: by auto => /> /#.
    by auto => />;smt(size_ge0 size_rcons ge0_t).
  by auto => />;smt(ge0_t size_ge0).
if{2}; last first. 
+ if{1};last first. 
  + rnd{2};wp;call(: ={glob O_SMDTOpenPRE_Default_early_fail}); 1: by sim.
    wp;while (#pre);1: by exfalso;smt().
    by auto => />;smt(drat_ll). 
  unroll {2} 1.
+ rcondt{2} 1; 1: by auto.
  rcondf{1} 2; 1: by auto => /#.
  rnd{2};wp;call(: ={glob O_SMDTOpenPRE_Default_early_fail}); 1: by sim.
  wp;while (
     ={_j,_i,ys0,pp_init,tws, tws_init, glob A, pp,glob O_SMDTOpenPRE_Default_early_fail} /\
    tws_init{1} = tws{1} /\
    _i{1} = ii /\
    _j{1} = jj /\
    O_SMDTOpenPRE_Default_early_fail._j{1} = jj /\
    O_SMDTOpenPRE_Default_early_fail._i{1} = ii /\
    O_SMDTOpenPRE_Default.pp{1} = pp_init{1} /\
    pp{1} = pp_init{1} /\ 
    size O_SMDTOpenPRE_Default.ts{1} <= min (size tws_init{1}) t /\
    (0 <= jj => !size O_SMDTOpenPRE_Default.ts{1} <= jj)
   ). 
  + rcondf{1} 2; 1: by auto;smt(size_ge0).
    by auto=>/>;smt(size_ge0 size_rcons ge0_t). 
  by auto=>/> ;smt(drat_ll size_ge0 size_rcons ge0_t). 

rcondt{1} 1; 1: by auto => /#.
rcondt{1} 2; 1: by auto => /#.
sp;seq 1 1 : (#pre /\ y1{1} = O_SMDTOpenPRE_Default_inverse_sample_alt.yj{2} /\
       (y1 \in dmap din (f pp (nth witness tws_init (size O_SMDTOpenPRE_Default.ts)))){1});1: by auto.
if;1: by auto.
+ case <- {2} 17.
  swap {2} [17..18] -16.
  swap {2} [25..26] -22.
  sp 0 2.
  seq 1 2 : (#pre /\ xt{1} = Si_inverse_sample_alt.x{2}); 1: by
    auto => />;smt(rngprefl_image supp_dmap).
wp;call(: jj \in O_SMDTOpenPRE_Default.os,
       nth witness O_SMDTOpenPRE_Default.xs{1} jj = Si_inverse_sample_alt.x{2} 
    /\ ={O_SMDTOpenPRE_Default.os} 
    /\ O_SMDTOpenPRE_Default_early_fail._j{1} = jj 
    /\ O_SMDTOpenPRE_Default_early_fail._i{1} = ii 
    /\ size O_SMDTOpenPRE_Default.ts{2} = size O_SMDTOpenPRE_Default.xs{2} 
    /\  (O_SMDTOpenPRE_Default_early_fail._i{1}, O_SMDTOpenPRE_Default_early_fail.r{1},
        O_SMDTOpenPRE_Default_early_fail._j{1}, O_SMDTOpenPRE_Default.os{1}, 
        O_SMDTOpenPRE_Default.ts{1}, O_SMDTOpenPRE_Default.pp{1}) =
       (O_SMDTOpenPRE_Default_early_fail._i{2}, O_SMDTOpenPRE_Default_early_fail.r{2},
        O_SMDTOpenPRE_Default_early_fail._j{2}, O_SMDTOpenPRE_Default.os{2}, 
        O_SMDTOpenPRE_Default.ts{2}, O_SMDTOpenPRE_Default.pp{2}) 
    /\ size O_SMDTOpenPRE_Default.xs{1} = size O_SMDTOpenPRE_Default.xs{2} 
    /\ jj < size O_SMDTOpenPRE_Default.ts{2} 
    /\ (forall kk, 0 <= kk < size O_SMDTOpenPRE_Default.xs{1} =>
        kk <> jj => nth witness O_SMDTOpenPRE_Default.xs{1} kk = 
                    nth witness O_SMDTOpenPRE_Default.xs{2} kk),
      jj \in O_SMDTOpenPRE_Default.os{1} <=> jj \in O_SMDTOpenPRE_Default.os{2}).
 + apply A_find_ll.
 + by proc;auto => />;smt(mem_rcons nth_default nth_neg).
 + by move => *;proc;auto => />;smt(mem_rcons nth_default nth_neg).
 + by move => *; proc;auto => />;smt(mem_rcons). 
 wp; while (
       ={_j,_i,ys0,pp_init,tws, tws_init, glob A, pp} 
    /\ tws_init{1} = tws{1} 
    /\ _i{1} = ii 
    /\ _j{1} = jj 
    /\ nth witness O_SMDTOpenPRE_Default.xs{1} jj = Si_inverse_sample_alt.x{2} 
    /\ O_SMDTOpenPRE_Default_early_fail._j{1} = jj 
    /\ O_SMDTOpenPRE_Default_early_fail._i{1} = ii 
    /\ O_SMDTOpenPRE_Default.pp{1} = pp_init{1} 
    /\ pp{1} = pp_init{1} 
    /\ size O_SMDTOpenPRE_Default.ts{2} = size O_SMDTOpenPRE_Default.xs{2} 
    /\ size ys0{2} = size O_SMDTOpenPRE_Default.ts{2} 
    /\ size O_SMDTOpenPRE_Default.ts{1} <= min (size tws_init{1}) t 
    /\ (O_SMDTOpenPRE_Default_early_fail._i{1}, O_SMDTOpenPRE_Default_early_fail.r{1},
        O_SMDTOpenPRE_Default_early_fail._j{1}, O_SMDTOpenPRE_Default.os{1}, 
        O_SMDTOpenPRE_Default.ts{1}, O_SMDTOpenPRE_Default.pp{1}) =
       (O_SMDTOpenPRE_Default_early_fail._i{2}, O_SMDTOpenPRE_Default_early_fail.r{2},
        O_SMDTOpenPRE_Default_early_fail._j{2}, O_SMDTOpenPRE_Default.os{2}, 
        O_SMDTOpenPRE_Default.ts{2}, O_SMDTOpenPRE_Default.pp{2}) 
    /\ size O_SMDTOpenPRE_Default.xs{1} = size O_SMDTOpenPRE_Default.xs{2} 
    /\ ( jj < size O_SMDTOpenPRE_Default.ts{2}) 
    /\   (forall kk, 0 <= kk < size O_SMDTOpenPRE_Default.xs{1} =>
        kk <> jj => nth witness O_SMDTOpenPRE_Default.xs{1} kk = 
                    nth witness O_SMDTOpenPRE_Default.xs{2} kk)).
    + rcondf{1} 2; 1: by auto => /> /#.
      by auto => />; smt(nth_rcons nth_neg nth_default size_rcons mem_rcons nth_default nth_neg).
    by auto => />;smt(nth_rcons nth_neg nth_default size_rcons mem_rcons nth_default nth_neg).

rnd{2};wp;call(: ={glob O_SMDTOpenPRE_Default_early_fail}); 1: by sim.
wp;while (
       ={_j,_i,ys0,pp_init,tws, tws_init, glob A, pp,glob O_SMDTOpenPRE_Default_early_fail} 
    /\ tws_init{1} = tws{1} 
    /\ _i{1} = ii 
    /\ _j{1} = jj 
    /\ O_SMDTOpenPRE_Default_early_fail._j{1} = jj 
    /\ O_SMDTOpenPRE_Default_early_fail._i{1} = ii 
    /\ O_SMDTOpenPRE_Default.pp{1} = pp_init{1} 
    /\ pp{1} = pp_init{1} 
    /\  size O_SMDTOpenPRE_Default.ts{1} <= min (size tws_init{1}) t 
    /\ (0 <= jj => !size O_SMDTOpenPRE_Default.ts{1} <= jj)
   ). 
+ rcondf{1} 2; 1: by auto;smt(size_ge0).
  by auto=>/>;smt(size_ge0 size_rcons ge0_t). 
by auto=>/> ;smt(drat_ll size_ge0 size_rcons ge0_t). 
qed.

local lemma PrSiis_Siisa_sub (_ii _jj : int) &1 &2 :
Pr[Si.main(_ii, _jj) @ &1 : res]=
Pr[Si_inverse_sample_alt.same_as_si(_ii, _jj) @ &2 :
      res.`3 = _jj 
   /\ O_SMDTOpenPRE_Default_early_fail.r 
   /\ (0 <= res.`3 && res.`3 < res.`4) 
   /\ (0 <= res.`4 && res.`4 <= t) 
   /\ ! res.`5 
   /\ res.`6 
   /\ f res.`1 res.`7 Si_inverse_sample_alt.x' = res.`8].
admitted.

local lemma pr_cond_neqxxp_Si (_ii,_jj : int) &m:
  Pr[Si.main(_ii,_jj) @ &m : res /\ Si.x' <> Si.x]
  =
  (_ii%r - 1%r) / _ii%r * Pr[Si.main(_ii,_jj) @ &m : res].
proof.
case (0 < _ii /\ 0 <= _jj) => bdij;last first.
+ rewrite (: Pr[Si.main(_ii,_jj) @ &m : res] = 0%r) 2:mulr0.
  - byphoare (_: arg.`1 <= 0 \/ arg.`2 < 0 ==> _) => //=;2:smt().
    hoare.
    proc.
    do 6!(wp;call (: true);1:by auto).
    by call(:true);auto; smt(size_ge0 rngprefl_image).
  byphoare (_: arg.`1 <= 0 \/ arg.`2 < 0 ==> _) => //=;2:smt().
  hoare.
  proc.
  do 6!(wp;call (: true);1:by auto).
  by call(:true);auto; smt(size_ge0 rngprefl_image).
rewrite pr_Si_Sief pr_Sief_Siis pr_Siis_Siisa mulrC.
pose prsi := Pr[Si.main(_ii,_jj) @ &m : res].
pose i1di := (_ii%r - 1%r) / _ii%r.
byphoare (: (glob A) = (glob A){m} /\ arg.`1 = _ii /\ arg.`2 = _jj ==> _) => //=.
proc. 
seq 1 : 
  (ii = _jj 
    /\ O_SMDTOpenPRE_Default_early_fail.r 
    /\ (0 <= ii < _nrts 
    /\ 0 <= _nrts <= t 
    /\ !_opened 
    /\ _dist 
    /\ f _pp _tw Si_inverse_sample_alt.x' = _y)) 
   prsi i1di _ 0%r 
      (((!O_SMDTOpenPRE_Default_early_fail.r) = 
           (0 <= _jj < _nrts 
        /\ (size (pre_f_l _pp 
           (nth witness O_SMDTOpenPRE_Default.ts _jj).`1 
             O_SMDTOpenPRE_Default_inverse_sample_alt.yj) <> _ii))) 
    /\ (_j = _jj) 
    /\ _tw = (nth witness O_SMDTOpenPRE_Default.ts ii).`1
    /\ _nrts{hr} = size O_SMDTOpenPRE_Default.ts{hr}
    /\ (_jj < size O_SMDTOpenPRE_Default.ts{hr} =>
          _y = (nth witness O_SMDTOpenPRE_Default.ts{hr} ii).`2) 
    /\ (_jj < size O_SMDTOpenPRE_Default.ts{hr} =>
          size (pre_f_l _pp (nth witness _tws{hr} _jj) 
           O_SMDTOpenPRE_Default_inverse_sample_alt.yj) = _ii =>
          (nth witness O_SMDTOpenPRE_Default.ts{hr} _jj).`2 = 
          O_SMDTOpenPRE_Default_inverse_sample_alt.yj)
    /\ (_jj < size O_SMDTOpenPRE_Default.ts{hr} =>
          nth witness _tws{hr} _jj = 
             (nth witness O_SMDTOpenPRE_Default.ts{hr} _jj).`1)) => //.
  + inline 1; wp => /=; swap  11 -2. 
    seq 9 : (#{/~tw = (nth witness O_SMDTOpenPRE_Default.ts i).`1}
          {~(_jj < size O_SMDTOpenPRE_Default.ts => 
              y = (nth witness O_SMDTOpenPRE_Default.ts i).`2)}post); last
      by inline *;auto;call(:true); auto. 
  inline *;wp => /=. 
  while (#post 
      /\ (_jj < min (size tws_init) t => 
              0< min (size tws_init) t => 
                _jj < size O_SMDTOpenPRE_Default.ts)
      );1: by auto => />; smt(nth_rcons size_rcons).
  seq 15 : (O_SMDTOpenPRE_Default_early_fail.r /\ 
     (!(size O_SMDTOpenPRE_Default.ts < min (size tws_init) t /\
        size O_SMDTOpenPRE_Default.ts < O_SMDTOpenPRE_Default_early_fail._j))
      /\ O_SMDTOpenPRE_Default.pp = pp
      /\ tws_init = tws
      /\ O_SMDTOpenPRE_Default_early_fail._j = _jj 
      /\ O_SMDTOpenPRE_Default_early_fail._i = _ii 
      /\ size O_SMDTOpenPRE_Default.ts = min _jj (min (size tws_init) t)
      /\ _j{hr} = _jj).
  + while (O_SMDTOpenPRE_Default_early_fail.r
      /\ O_SMDTOpenPRE_Default.pp = pp
      /\ tws_init = tws
      /\ O_SMDTOpenPRE_Default_early_fail._i = _ii 
      /\ O_SMDTOpenPRE_Default_early_fail._j = _jj 
      /\ O_SMDTOpenPRE_Default_early_fail._i = _ii 
      /\ size O_SMDTOpenPRE_Default.ts <= min (size tws_init) t 
       /\  (size O_SMDTOpenPRE_Default.ts <= _jj) 
       /\ _j{hr} = _jj); 1: by auto;smt(size_ge0 mem_rcons nth_rcons size_rcons).
    by wp;call(:true);auto => />; smt(ge0_t size_ge0).
  if;sp 1;seq 1 : #pre;1: by auto.
    + by auto => />;smt(nth_rcons size_rcons).  
  by auto => />;smt(nth_rcons size_rcons).
by auto => />;smt(nth_rcons size_rcons).

+ call (_ : (glob A) = (glob A){m} /\ arg.`1 = _ii /\ arg.`2 = _jj ==> 
      res.`3 = _jj /\ O_SMDTOpenPRE_Default_early_fail.r 
   /\ (0 <= res.`3 && res.`3 < res.`4) 
   /\ (0 <= res.`4 && res.`4 <= t) /\ !res.`5 /\ res.`6 
   /\ f res.`1 res.`7 Si_inverse_sample_alt.x' = res.`8) => //.
  rewrite /prsi; bypr => //= &m' [eqglob [-> ->]].
  by rewrite eq_sym; apply (PrSiis_Siisa_sub _ii _jj).

+ rnd (fun x => x <>  Si_inverse_sample_alt.x').
  auto  => /> &hr *; rewrite ifF 1:/# prratE /= /i1di;congr;last by smt(). 
   have : Si_inverse_sample_alt.x'{hr} \in 
    pre_f_l _pp{hr} (nth witness O_SMDTOpenPRE_Default.ts{hr} _jj).`1 
       O_SMDTOpenPRE_Default_inverse_sample_alt.yj{hr} by smt(mem_to_seq is_finite_ispref).
    by have := count_predC (fun (x : in_t) => x <> Si_inverse_sample_alt.x'{hr}) 
        (pre_f_l _pp{hr} (nth witness O_SMDTOpenPRE_Default.ts{hr} _jj).`1 
          O_SMDTOpenPRE_Default_inverse_sample_alt.yj{hr});
           rewrite /predC /= count_uniq_mem; smt(uniq_to_seq).
by hoare;auto => />. 
qed.


local lemma pr_OpenPRE_bigSi &m :
  Pr[SM_DT_OpenPRE(A, O_SMDTOpenPRE_Default).main() @ &m : res]
  =
  bigi predT (fun j =>
    Pr[Si.main(1,j) @ &m : res]
    +
    bigi predT (fun (i : int) => Pr[Si.main(i,j) @ &m : res]) 2 (card + 1)) 0 t.
proof.
(* have ->: Pr[PRE(A).main() @ &m : res] = Pr[PREg.main() @ &m : res].
+ by byequiv=> //=; sim.
*)
rewrite (: Pr[Si.main(1,j) @ &m : res] = (fun (ii jj : int) => Pr[Si.main(ii,jj) @ &m : res]) 1 j) //.
rewrite -big_consT -range_ltn; 1: smt(card_gt0).
rewrite Pr[mu_split (1 <= size (pre_f_l PREg.k PREg.y) <= card)] -(addr0 (big _ _ _)).
congr; last first.
+ byphoare => //=.
  hoare.
  proc.
  call (: true).
  wp; rnd; rnd; skip => /> k kin x xin x'.
  by rewrite rngprefl_image.
suff:
  forall (i : int),
    0 <= i => 
      Pr[PREg.main() @ &m : res /\ 1 <= size (pre_f_l PREg.k PREg.y) <= i]
      =
      bigi predT (fun (i : int) => Pr[Si.main(i) @ &m : res]) 1 (i + 1).
+ by move => /(_ card); smt(size_ge0).
elim => /= [ | i ge0_i ih].
+ rewrite range_geq 1:// big_nil.
  by byphoare (: _ ==> false) => // /#.
rewrite (: i + 2 = i + 1 + 1) 1:// rangeSr 1:/# big_rcons /predT /= -/predT.
rewrite -ih Pr[mu_split (size (pre_f_l PREg.k PREg.y) = i + 1)] addrC.
congr; last first.
+ byequiv => //=.
  proc.
  call (: true).
  wp; rnd; rnd; skip => /> /#.
byequiv => //=.
proc.
call (: true).
by wp; rnd; rnd; skip => /> /#.

 admit. 
qed.


local lemma pr_DSPR_bigSiFi &m :
  Pr[SM_DT_DSPR(R_DSPR_OpenPRE(A), O_SMDTDSPR_Default).main() @ &m : res]
  =
  Pr[Si.main(1) @ &m : res] 
  +
  bigi predT (fun (i : int) => (i%r - 1%r) / i%r * Pr[Si.main(i) @ &m : res]) 2 (card + 1)
  +
  bigi predT (fun (i : int) => Pr[Fi.main(i) @ &m : res]) 2 (card + 1).
proof. admit. qed.


local lemma pr_SPprob_bigSi &m: 
  Pr[SM_DT_SPprob(R_DSPR_OpenPRE(A), O_SMDTDSPR_Default).main() @ &m : res]
  =
  bigi predT (fun (i : int) => Pr[Si.main(i) @ &m : res]) 2 (card + 1)
  +
  bigi predT (fun (i : int) => Pr[Fi.main(i) @ &m : res]) 2 (card + 1).
proof. admit. qed.


local lemma pr_DSPRSPprob_bigSi &m :
  Pr[SM_DT_DSPR(R_DSPR_OpenPRE(A), O_SMDTDSPR_Default).main() @ &m : res]
  -
  Pr[SM_DT_SPprob(R_DSPR_OpenPRE(A), O_SMDTDSPR_Default).main() @ &m : res]
  =
  Pr[Si.main(1) @ &m : res] 
  -
  bigi predT (fun (i : int) => 1%r / i%r * Pr[Si.main(i) @ &m : res]) 2 (card + 1).
proof.
rewrite pr_DSPR_bigSiFi pr_SPprob_bigSi.
field; rewrite -big_split /= subr_eq0 &(eq_big_seq) => i /mem_range rng_i /=.
rewrite -mulrDl -{1}mul1r -mulrDl (: 1%r + (i%r - 1%r) = i%r) 1:/#.
by rewrite mulrC mulrA mulVf 1:/#.
qed.


local lemma pr_TCR_bigSi &m :
  Pr[SM_DT_TCR(R_TCR_OpenPRE(A), O_SMDTTCR_Default).main() @ &m : res]
  =
  bigi predT (fun (i : int) => (i%r - 1%r) / i%r * Pr[Si.main(i) @ &m : res]) 2 (card + 1).
proof. admit. qed.


lemma OpenPRE_From_DSPR_TCR &m :
  Pr[SM_DT_OpenPRE(A, O_SMDTOpenPRE_Default).main() @ &m : res]
  <= 
  maxr 0%r 
       (Pr[SM_DT_DSPR(R_DSPR_OpenPRE(A), O_SMDTDSPR_Default).main() @ &m : res]
        -
        Pr[SM_DT_SPprob(R_DSPR_OpenPRE(A), O_SMDTDSPR_Default).main() @ &m : res])
  +
  3%r * Pr[SM_DT_TCR(R_TCR_OpenPRE(A), O_SMDTTCR_Default).main() @ &m : res].
proof.
apply (ler_trans 
        (Pr[SM_DT_DSPR(R_DSPR_OpenPRE(A), O_SMDTDSPR_Default).main() @ &m : res]
         -
         Pr[SM_DT_SPprob(R_DSPR_OpenPRE(A), O_SMDTDSPR_Default).main() @ &m : res] 
         +
         3%r * Pr[SM_DT_TCR(R_TCR_OpenPRE(A), O_SMDTTCR_Default).main() @ &m : res])); last first.
+ by apply ler_add; 1: rewrite maxrr.
rewrite pr_OpenPRE_bigSi pr_DSPRSPprob_bigSi pr_TCR_bigSi.
rewrite -addrA &(ler_add) 1:// addrC mulrC mulr_suml sumrB /=.
apply ler_sum_seq => i /mem_range rng_i _ /=.
rewrite mulrC 2!mulrA mulrDr /= divrr 1:/# /=.
rewrite mulrAC mulrDl /= 2!mulNr /= mulrC -mulrBr.
by rewrite &(ler_pemulr) 1:Pr[mu_ge0] // /#.
qed.

end section Proof_OpenPRE_From_DSPR_TCR.
